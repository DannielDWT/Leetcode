# SOLUTION

**方法一 -- 摩尔投票算法**
该算法在其局部变量中维护一个临时变量m和一个计数器c，计数器初值为零。 然后我们遍历序列中的每个元素。如果c==0，则m=x;c=1;（其中x表示我们遍历到的元素）。 如果m==x，那么c++，否则c--。 最后返回m即可。

这个方法相当于将元素划为两类，由于众数超过一半，所以可以通过两个类别的数目之差判断众数是哪个。当一开始选中的即是众数时，根据上述即可知可以得出正确结果。当选中不是众数，其必然会被替换，而替换后，由于前面去掉的元素中真正众数至少不多于其余数，那么剩下的数目中，原众数的数目仍然是超过半数甚至更多，因而仍然能获取到真正的众数。

该算法的最简单的形式，查找最多出现的元素，也就是找到一个输入中出现一半以上的重复元素。但是，如果该数不存在的话，算法将检测不到真实结果，但是仍将输出输入元素中的一个元素。 但是，我们可以再次遍历输入序列，计算返回元素出现的次数，以确定它是否真的是众数。
```C++
class Solution {
int majorityElement(vector<int> &nums)
{
	
	int m = nums[0];
	int c = 0;
	for (auto num: nums)
	{
		if (c == 0)
		{
			m = num;
			++c;
		}
		else if (m == num)
		{
			++c;
		}
		else
		{
			--c;
		}
	}
	return m;
}
}
```


